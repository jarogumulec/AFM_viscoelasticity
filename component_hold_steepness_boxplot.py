import os
from typing import List, Dict
from itertools import combinations

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from scipy import stats
"""Compute steepness from per-component averaged curves without CLI args."""

# Directory with per-component AVERAGED CSVs generated by masked_height_curves.py
curves_dir = '/data/2025-09-05_curves'
# Output directory for plots and aggregated CSVs
plots_dir = '/data/2025-09-05_group_plots'

# Portion of the curve to use for slope fit: last 4/5 = 0.8
TAIL_FRACTION = 0.8


def file_group_from_name(name: str) -> str:
    s = name.lower()
    cond = 'ctrl' if 'ctrl' in s else ('bleb' if 'bleb' in s else 'unknown')
    dish = 'dish1' if 'dish1' in s else ('dish2' if 'dish2' in s else 'unknown')
    return f'{cond}-{dish}'


def find_avg_csvs(root: str) -> List[str]:
    files: List[str] = []
    for dirpath, _, filenames in os.walk(root):
        for fn in filenames:
            fp = os.path.join(dirpath, fn)
            if fn.endswith('_hold_avg_time.csv'):
                files.append(fp)
    return sorted(files)


def linear_slope_last_tail(x: np.ndarray, y: np.ndarray, frac: float = TAIL_FRACTION) -> float | None:
    if x.size < 3 or y.size != x.size:
        return None
    start = int(np.floor((1.0 - frac) * x.size))
    if start >= x.size - 1:
        return None
    x_tail = x[start:]
    y_tail = y[start:]
    # Remove NaNs
    msk = np.isfinite(x_tail) & np.isfinite(y_tail)
    x_tail = x_tail[msk]
    y_tail = y_tail[msk]
    if x_tail.size < 2:
        return None
    # Fit y = a*x + b
    a, _b = np.polyfit(x_tail, y_tail, 1)
    return float(a)


def main():
    # Use module-level directories directly (no CLI arguments)
    cd = curves_dir
    pdout = plots_dir

    avg_csvs = find_avg_csvs(cd)
    if not avg_csvs:
        print(f'No per-component averaged CSVs found under {cd}')
        return

    rows: List[Dict] = []
    for csv_path in avg_csvs:
        try:
            df = pd.read_csv(csv_path)
        except Exception as e:
            print(f'Skip {csv_path}: cannot read ({e})')
            continue
        req = {'file', 'time_s', 'height_um_mean'}
        if not req.issubset(df.columns) or df.empty:
            print(f'Skip {csv_path}: missing required columns {req - set(df.columns)}')
            continue
        base = str(df['file'].iloc[0])
        group = file_group_from_name(base)
        comp_id = int(df['component_id'].iloc[0]) if 'component_id' in df.columns else None

        dfg = df.sort_values('time_s')
        t = dfg['time_s'].to_numpy(dtype=float)
        y = dfg['height_um_mean'].to_numpy(dtype=float)
        slope = linear_slope_last_tail(t, y, frac=TAIL_FRACTION)
        if slope is None or not np.isfinite(slope):
            continue
        rows.append({
            'file': base,
            'component_id': comp_id if comp_id is not None else np.nan,
            'group': group,
            'slope_um_per_s': float(slope),
            'curve_duration_s': float(np.nanmax(t) - np.nanmin(t)) if t.size > 1 else np.nan,
        })

    if not rows:
        print('No slopes computed; nothing to plot')
        return

    slopes_df = pd.DataFrame(rows)
    os.makedirs(pdout, exist_ok=True)
    out_csv = os.path.join(pdout, 'hold_steepness_from_avg_slopes_last80_per_s.csv')
    slopes_df.to_csv(out_csv, index=False)
    print(f'Saved: {out_csv}')

    # Boxplot per group (simple)
    plt.figure(figsize=(8, 4.2), dpi=150)
    ax = sns.boxplot(data=slopes_df, x='group', y='slope_um_per_s')
    sns.stripplot(data=slopes_df, x='group', y='slope_um_per_s', ax=ax, color='k', alpha=0.4, jitter=0.15)
    ax.set_title('Hold steepness from average curves (last 4/5) — µm/s')
    ax.set_ylabel('slope [µm/s]')
    ax.set_xlabel('group')
    plt.tight_layout()
    out_png = os.path.join(pdout, 'hold_steepness_from_avg_boxplot_last80_per_s.png')
    plt.savefig(out_png, dpi=150)
    plt.close()
    print(f'Saved: {out_png}')

    # Very simple pairwise p-values table (Welch t-test only)
    from itertools import combinations
    groups_present = sorted(slopes_df['group'].dropna().unique().tolist())
    results = []
    for g1, g2 in combinations(groups_present, 2):
        a = slopes_df.loc[slopes_df['group'] == g1, 'slope_um_per_s'].dropna().to_numpy()
        b = slopes_df.loc[slopes_df['group'] == g2, 'slope_um_per_s'].dropna().to_numpy()
        if a.size < 2 or b.size < 2:
            continue
        _t, p = stats.ttest_ind(a, b, equal_var=False)
        results.append({
            'group1': g1,
            'group2': g2,
            'n1': int(a.size),
            'n2': int(b.size),
            'mean1_um_per_s': float(np.mean(a)),
            'mean2_um_per_s': float(np.mean(b)),
            'diff_mean_um_per_s': float(np.mean(a) - np.mean(b)),
            'pvalue_welch': float(p),
        })

    if results:
        pairwise_csv = os.path.join(pdout, 'hold_steepness_from_avg_pvalues_pairwise_per_s.csv')
        pd.DataFrame(results).to_csv(pairwise_csv, index=False)
        print(f'Saved: {pairwise_csv}')

    # Mixed dishes: ctrl vs bleb only (aggregate both dishes)
    def cond_from_group(g: str) -> str:
        g = (g or '').lower()
        if g.startswith('ctrl-') or g == 'ctrl':
            return 'ctrl'
        if g.startswith('bleb-') or g == 'bleb':
            return 'bleb'
        return 'unknown'

    slopes_df['cond'] = slopes_df['group'].map(cond_from_group)
    sub = slopes_df[slopes_df['cond'].isin(['ctrl', 'bleb'])]
    a = sub.loc[sub['cond'] == 'ctrl', 'slope_um_per_s'].dropna().to_numpy()
    b = sub.loc[sub['cond'] == 'bleb', 'slope_um_per_s'].dropna().to_numpy()
    if a.size >= 2 and b.size >= 2:
        _t, p = stats.ttest_ind(a, b, equal_var=False)
        # Save simple one-row CSV
        mixed_csv = os.path.join(pdout, 'hold_steepness_from_avg_pvalues_ctrl_vs_bleb_mixed_per_s.csv')
        pd.DataFrame([{
            'comparison': 'ctrl_vs_bleb_mixed',
            'n_ctrl': int(a.size),
            'n_bleb': int(b.size),
            'mean_ctrl_um_per_s': float(np.mean(a)),
            'mean_bleb_um_per_s': float(np.mean(b)),
            'diff_mean_um_per_s': float(np.mean(a) - np.mean(b)),
            'pvalue_welch': float(p),
        }]).to_csv(mixed_csv, index=False)
        print(f'Saved: {mixed_csv}')

        # Simple two-box plot: ctrl vs bleb (mixed dishes)
        plt.figure(figsize=(6, 4), dpi=150)
        ax = sns.boxplot(data=sub, x='cond', y='slope_um_per_s')
        sns.stripplot(data=sub, x='cond', y='slope_um_per_s', ax=ax, color='k', alpha=0.4, jitter=0.15)
        ax.set_title('Hold steepness from avg curves — ctrl vs bleb (mixed)')
        ax.set_ylabel('slope [µm/s]')
        ax.set_xlabel('condition')
        plt.tight_layout()
        mixed_png = os.path.join(pdout, 'hold_steepness_from_avg_boxplot_ctrl_vs_bleb_mixed_last80_per_s.png')
        plt.savefig(mixed_png, dpi=150)
        plt.close()
        print(f'Saved: {mixed_png}')


if __name__ == '__main__':
    main()
