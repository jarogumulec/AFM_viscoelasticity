import os
from typing import Dict, List, Tuple

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Input directory containing per-component averaged CSVs generated by masked_height_curves.py
curves_dir = '/data/2025-09-05_curves'
# Output directory for group plots
plots_dir = '/data/2025-09-05_group_plots'

# Colors for groups
GROUP_COLORS = {
    'ctrl-dish1': '#1f77b4',
    'ctrl-dish2': '#ff7f0e',
    'bleb-dish1': '#2ca02c',
    'bleb-dish2': '#d62728',
}


def file_group_from_name(name: str) -> str:
    s = name.lower()
    cond = 'ctrl' if 'ctrl' in s else ('bleb' if 'bleb' in s else 'unknown')
    dish = 'dish1' if 'dish1' in s else ('dish2' if 'dish2' in s else 'unknown')
    return f'{cond}-{dish}'


def find_avg_csvs(root: str) -> List[str]:
    files: List[str] = []
    for dirpath, _, filenames in os.walk(root):
        for fn in filenames:
            if fn.endswith('_hold_avg_time.csv'):
                files.append(os.path.join(dirpath, fn))
    return sorted(files)


def load_avg_curves_by_group(root: str) -> Dict[str, List[Tuple[np.ndarray, np.ndarray]]]:
    """
    Return dict group -> list of (t_s, height_um_mean)
    """
    groups: Dict[str, List[Tuple[np.ndarray, np.ndarray]]] = {}
    for csv_path in find_avg_csvs(root):
        try:
            df = pd.read_csv(csv_path)
        except Exception as e:
            print(f'Skip {csv_path}: cannot read ({e})')
            continue
        req = {'file', 'time_s', 'height_um_mean'}
        if df.empty or not req.issubset(df.columns):
            print(f'Skip {csv_path}: missing required columns {req - set(df.columns)}')
            continue
        base = str(df['file'].iloc[0])
        grp = file_group_from_name(base)
        t = df['time_s'].to_numpy(dtype=float)
        y_um = df['height_um_mean'].to_numpy(dtype=float)
        if t.size < 2 or y_um.size != t.size:
            continue
        groups.setdefault(grp, []).append((t, y_um))
    return groups


def align_and_stack_time(curves: List[Tuple[np.ndarray, np.ndarray]], n_points: int = 200) -> Tuple[np.ndarray, np.ndarray]:
    if not curves:
        return np.array([]), np.zeros((0,))
    # Common domain: 0..min max time across curves
    t_max_common = min(float(np.max(t)) for t, _ in curves if t.size > 1)
    if not np.isfinite(t_max_common) or t_max_common <= 0:
        return np.array([]), np.zeros((0,))
    t_grid = np.linspace(0.0, t_max_common, n_points)
    mats: List[np.ndarray] = []
    for t, y in curves:
        msk = np.isfinite(t) & np.isfinite(y)
        t2 = t[msk]
        y2 = y[msk]
        if t2.size < 2:
            continue
        try:
            mats.append(np.interp(t_grid, t2, y2))
        except Exception:
            continue
    if not mats:
        return np.array([]), np.zeros((0,))
    return t_grid, np.vstack(mats)


def compute_group_stats(groups: Dict[str, List[Tuple[np.ndarray, np.ndarray]]], method: str, n_points: int = 200):
    """Normalize each per-component average curve, align, then average across components.
    method in {'divide', 'subtract'}
    returns: dict group -> (t, mean, std, n)
    """
    out = {}
    for grp, lst in groups.items():
        proc: List[Tuple[np.ndarray, np.ndarray]] = []
        for t, y in lst:
            m = np.nanmean(y)
            if not np.isfinite(m):
                continue
            if method == 'divide':
                if np.isclose(m, 0.0):
                    continue
                yn = y / m
            elif method == 'subtract':
                yn = y - m
            else:
                raise ValueError('Unknown method')
            proc.append((t, yn))
        if not proc:
            continue
        tx, A = align_and_stack_time(proc, n_points=n_points)
        if A.size == 0:
            continue
        out[grp] = (tx, np.nanmean(A, axis=0), np.nanstd(A, axis=0), A.shape[0])
    return out


def plot_groups(stats: Dict[str, Tuple[np.ndarray, np.ndarray, np.ndarray, int]], title: str, ylabel: str, out_path: str, x_label: str = 'time (s)'):
    os.makedirs(os.path.dirname(out_path), exist_ok=True)
    fig, ax = plt.subplots(figsize=(8, 4.2), dpi=150)
    for grp, (x, mean, std, n) in stats.items():
        if mean.size == 0:
            continue
        color = GROUP_COLORS.get(grp)
        label = f'{grp} (n={n})'
        ax.plot(x, mean, label=label, color=color)
        ax.fill_between(x, mean - std, mean + std, color=color, alpha=0.15, linewidth=0)
    ax.set_title(title)
    ax.set_xlabel(x_label)
    ax.set_ylabel(ylabel)
    ax.legend(loc='best')
    fig.tight_layout()
    fig.savefig(out_path, dpi=150)
    plt.close(fig)
    print(f'Saved: {out_path}')


def save_stats_csv(stats: Dict[str, Tuple[np.ndarray, np.ndarray, np.ndarray, int]], out_path: str, *, domain: str, method: str, x_label: str, y_unit: str):
    rows = []
    for grp, (x, mean, std, n) in stats.items():
        for xi, mu, sd in zip(x, mean, std):
            rows.append({
                'group': grp,
                'domain': domain,
                'method': method,
                'x': float(xi),
                'mean': float(mu),
                'std': float(sd),
                'n': int(n),
                'x_label': x_label,
                'y_unit': y_unit,
            })
    if not rows:
        print(f'No data to save for {out_path}')
        return
    os.makedirs(os.path.dirname(out_path), exist_ok=True)
    pd.DataFrame(rows).to_csv(out_path, index=False)
    print(f'Saved: {out_path}')


def main():
    groups = load_avg_curves_by_group(curves_dir)
    if not groups:
        print(f'No per-component averaged CSVs found under {curves_dir}.')
        return

    # Divide-by-mean (a.u.) — average of per-component averages
    stats_div = compute_group_stats(groups, method='divide', n_points=200)
    out_div = os.path.join(plots_dir, 'hold_group_divide_by_mean_time.png')
    plot_groups(stats_div, title='Hold — group averages of averages (divide by mean)', ylabel='relative height (a.u.)', out_path=out_div, x_label='time (s)')
    csv_div = os.path.join(plots_dir, 'hold_group_divide_by_mean_time.csv')
    save_stats_csv(stats_div, csv_div, domain='time', method='divide', x_label='time (s)', y_unit='a.u.')

    # Subtract-mean (µm) — average of per-component averages
    stats_sub = compute_group_stats(groups, method='subtract', n_points=200)
    out_sub = os.path.join(plots_dir, 'hold_group_subtract_mean_um_time.png')
    plot_groups(stats_sub, title='Hold — group averages of averages (subtract mean)', ylabel='height (µm, centered)', out_path=out_sub, x_label='time (s)')
    csv_sub = os.path.join(plots_dir, 'hold_group_subtract_mean_um_time.csv')
    save_stats_csv(stats_sub, csv_sub, domain='time', method='subtract', x_label='time (s)', y_unit='µm')


if __name__ == '__main__':
    main()
